// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: charts.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getActiveSales = `-- name: GetActiveSales :one
SELECT COUNT(id) FROM sales WHERE is_paid = 0
`

func (q *Queries) GetActiveSales(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveSales)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getClientStatusCount = `-- name: GetClientStatusCount :many
SELECT 
    s.id as status_id,
    s.description as status_name,
    COUNT(c.id) as client_count
FROM states s
LEFT JOIN clients c ON s.id = c.state_id
WHERE s.id IN (1, 2, 3)
GROUP BY s.id, s.description
ORDER BY s.id
`

type GetClientStatusCountRow struct {
	StatusID    int64
	StatusName  string
	ClientCount int64
}

func (q *Queries) GetClientStatusCount(ctx context.Context) ([]GetClientStatusCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientStatusCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientStatusCountRow
	for rows.Next() {
		var i GetClientStatusCountRow
		if err := rows.Scan(&i.StatusID, &i.StatusName, &i.ClientCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuotaMonthlySummary = `-- name: GetQuotaMonthlySummary :many
SELECT 
    strftime('%Y-%m', due_date) as month,
    SUM(amount) as total_amount,
    SUM(CASE WHEN is_paid = 1 THEN amount ELSE 0 END) as amount_paid,
    SUM(CASE WHEN is_paid = 0 THEN amount ELSE 0 END) as amount_not_paid
FROM quotas 
WHERE due_date IS NOT NULL
GROUP BY strftime('%Y-%m', due_date)
ORDER BY month DESC
`

type GetQuotaMonthlySummaryRow struct {
	Month         interface{}
	TotalAmount   sql.NullFloat64
	AmountPaid    sql.NullFloat64
	AmountNotPaid sql.NullFloat64
}

func (q *Queries) GetQuotaMonthlySummary(ctx context.Context) ([]GetQuotaMonthlySummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuotaMonthlySummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuotaMonthlySummaryRow
	for rows.Next() {
		var i GetQuotaMonthlySummaryRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalAmount,
			&i.AmountPaid,
			&i.AmountNotPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalClients = `-- name: GetTotalClients :one
SELECT COUNT(id) FROM clients
`

func (q *Queries) GetTotalClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalProducts = `-- name: GetTotalProducts :one
SELECT COUNT(id) FROM products
`

func (q *Queries) GetTotalProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalRevenue = `-- name: GetTotalRevenue :one
SELECT IFNULL(SUM(amount), 0) FROM payments
`

func (q *Queries) GetTotalRevenue(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalRevenue)
	var ifnull interface{}
	err := row.Scan(&ifnull)
	return ifnull, err
}

const getTotalSales = `-- name: GetTotalSales :one
SELECT COUNT(id) FROM sales
`

func (q *Queries) GetTotalSales(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalSales)
	var count int64
	err := row.Scan(&count)
	return count, err
}
